<!DOCTYPE html>
<html lang="en"
      x-data="mainApp()"
      x-init="init()"
      :class="{ 'dark': darkMode }">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>NeuroTask</title>

    <!-- Tailwind CSS build -->
    <link href="/static/output.css" rel="stylesheet">

    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- htmx (for SSE and partial page updates) -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>

    <style>
        [x-cloak] { display: none !important; }
        .ai-loader {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-gray-100 to-gray-200 
             dark:from-gray-900 dark:to-gray-800 min-h-screen 
             text-gray-800 dark:text-gray-200">

    <div class="container mx-auto px-4 py-8 max-w-3xl">
        
        <!-- HEADER -->
        <div class="flex justify-between items-center mb-12">
            <h1 class="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                NeuroTask
            </h1>
            <!-- Dark Mode Toggle -->
            <button @click="toggleDarkMode()"
                    class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
                    title="Toggle Dark Mode">
                ðŸŒ™
            </button>
        </div>

        <!-- Test Notifications Button -->
        <div class="mb-4 text-right">
            <button @click="testNotification"
                    class="text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                Test Notifications
            </button>
        </div>

        <!-- =========== COMBINED ADD TASK / AI FORM =========== -->
        <div class="mb-8 bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-xl">
            <h2 class="text-lg font-bold mb-3 text-gray-800 dark:text-gray-200">
                Add Task (Manual) or Use AI
            </h2>
            <form @submit.prevent="addTask" class="space-y-4">
                <!-- Shared field for manual or AI prompt -->
                <input x-model="newTask"
                       type="text"
                       placeholder="Type a task or AI prompt (e.g., items needed to cook jollof)"
                       class="w-full p-3 rounded-xl border border-gray-200 
                              dark:border-gray-700 bg-transparent 
                              focus:outline-none focus:ring-2 focus:ring-blue-500">

                <!-- Responsive grid for date & priority -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <input x-model="newDueDate"
                           type="datetime-local"
                           class="p-3 rounded-xl border border-gray-200 
                                  dark:border-gray-700 bg-transparent">
                    
                    <select x-model="newPriority"
                            class="p-2 rounded-xl border border-gray-200 
                                   dark:border-gray-700 bg-transparent">
                      <option value="low">Low</option>
                      <option value="medium" selected>Medium</option>
                      <option value="high">High</option>
                    </select>
                </div>

                <!-- Two buttons: manual Add Task or AI Auto-Add -->
                <div class="text-right flex gap-2 justify-end mt-2">
                    <!-- Manual Add Task -->
                    <button type="submit"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold p-3 rounded-xl transition-all">
                        Add Task ðŸš€
                    </button>
                    <!-- AI Auto-Add -->
                    <button type="button"
                            @click="aiAutoAdd()"
                            :disabled="isAILoading"
                            class="bg-green-600 hover:bg-green-700 text-white p-3 rounded-xl transition-all flex items-center gap-2">
                      <span x-show="!isAILoading">AI Auto-Add</span>
                      <span x-show="isAILoading" class="ai-loader">ðŸŒ€</span>
                    </button>
                </div>
            </form>
        </div>

        <!-- AI PROPOSED TASK PANEL -->
        <div x-show="showAutoAddModal"
             x-cloak
             class="mb-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-xl shadow">
          <h3 class="text-lg font-bold mb-2 text-gray-800 dark:text-gray-200">
            AI Proposed Task
          </h3>
          <div class="mb-2">
            <strong>Main Task:</strong>
            <span x-text="aiAutoAddResult.main_task" class="ml-2 text-sm"></span>
          </div>
          <div class="mb-2">
            <strong>Subtasks:</strong>
            <template x-for="(sub, idx) in aiAutoAddResult.subtasks" :key="idx">
              <div class="ml-4 list-disc" x-text="sub"></div>
            </template>
            <template x-if="aiAutoAddResult.subtasks.length === 0">
              <div class="ml-4 text-xs italic">(No subtasks)</div>
            </template>
          </div>
          <div class="text-sm">
            <p><strong>Date:</strong> <span x-text="newDueDate || '(none)'"></span></p>
            <p><strong>Priority:</strong> <span x-text="newPriority"></span></p>
          </div>
          <div class="mt-4 flex gap-4">
            <!-- Edit in Form -> Overwrite newTask with AI's main_task -->
            <button @click="editAutoAdd()" 
                    class="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded">
              Edit in Form
            </button>
            <!-- Add Immediately -> Insert the AI main task + subtasks using newDueDate/newPriority -->
            <button @click="addAutoAdd()"
                    class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">
              Add Immediately
            </button>
          </div>
        </div>

        <!-- FILTER & SORT CONTROLS -->
        <div class="mb-4 flex flex-col md:flex-row items-start md:items-center gap-2">
          <!-- Search Input -->
          <input
            x-model="searchQuery"
            type="text"
            placeholder="Search tasks..."
            class="p-2 border rounded-md dark:bg-gray-900 dark:text-white w-full md:w-auto"
          >

          <!-- Priority Filter -->
          <select
            x-model="filterPriority"
            class="p-2 border rounded-md dark:bg-gray-900 dark:text-white"
          >
            <option value="">All Priorities</option>
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>

          <!-- Sort Option -->
          <select
            x-model="sortOption"
            class="p-2 border rounded-md dark:bg-gray-900 dark:text-white"
          >
            <option value="dueAsc">Due Date (Asc)</option>
            <option value="dueDesc">Due Date (Desc)</option>
            <option value="priorityDesc">Priority (Highâ†’Low)</option>
            <option value="priorityAsc">Priority (Lowâ†’High)</option>
          </select>
        </div>

        <!-- TASK LIST (filtered & sorted) -->
        <div class="space-y-4" hx-get="/tasks" hx-trigger="sse:task_update">
          <template x-for="task in filteredAndSortedTasks()" :key="task.id">
            <div class="bg-white dark:bg-gray-800 p-4 rounded-xl shadow-lg hover:shadow-xl transition-shadow relative">

              <!-- Main Task Checkbox -->
              <div class="absolute left-2 top-1/2 -translate-y-1/2">
                <input
                  type="checkbox"
                  :checked="task.completed"
                  @change="toggleCompletion(task.id, $event.target.checked)"
                  class="h-5 w-5 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                >
              </div>

              <!-- Priority Badge (top-right) -->
              <div class="absolute top-2 right-2 z-10">
                <span :class="{
                    'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100': task.priority === 'low',
                    'bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-100': task.priority === 'medium',
                    'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100': task.priority === 'high'
                  }"
                  class="px-2 py-1 rounded-full text-xs font-medium">
                  <span x-text="task.priority.charAt(0).toUpperCase() + task.priority.slice(1)"></span>
                </span>
              </div>

              <!-- Main Task Content -->
              <div class="flex items-center justify-between w-full">
                <div class="flex items-center gap-4 flex-1">
                  <!-- Delete Main Task -->
                  <button @click="deleteTask(task.id)"
                          class="text-red-500 hover:text-red-600 transition-colors shrink-0">
                    âœ•
                  </button>
                  <!-- Task Title/Text -->
                  <span x-text="task.task"
                        class="text-gray-800 dark:text-gray-200 truncate"
                        :class="task.completed ? 'line-through text-gray-500' : ''">
                  </span>
                </div>
                <!-- Due Date -->
                <div class="shrink-0">
                  <span x-text="new Date(task.due_date).toLocaleString()"
                        class="due-date text-sm text-gray-500 dark:text-gray-400">
                  </span>
                </div>
              </div>

              <!-- SUBTASK SECTION -->
              <div class="mt-4 pl-8 border-l border-gray-300 dark:border-gray-700">
                <h4 class="text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300">
                  Subtasks
                </h4>
                <!-- Existing subtasks -->
                <template x-for="subtask in subtasks[task.id]" :key="subtask.id">
                  <div class="flex items-center justify-between mb-2">
                    <!-- Subtask checkbox + text -->
                    <div class="flex items-center gap-2">
                      <input 
                        type="checkbox"
                        :checked="subtask.completed"
                        @change="toggleSubtaskCompletion(task.id, subtask)"
                        class="h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                      >
                      <span 
                        x-text="subtask.subtask"
                        :class="subtask.completed ? 'line-through text-gray-400' : ''"
                      ></span>
                    </div>
                    <!-- Delete subtask -->
                    <button
                      @click="deleteSubtask(task.id, subtask.id)"
                      class="text-red-500 hover:text-red-700 text-sm"
                    >
                      Delete
                    </button>
                  </div>
                </template>
                <!-- Add new subtask -->
                <div class="flex items-center gap-2 mt-3">
                  <input
                    x-ref="subtaskInput"
                    type="text"
                    placeholder="Add subtask..."
                    class="w-full p-2 border rounded-md 
                           dark:bg-gray-900 dark:text-white"
                  >
                  <button
                    @click="
                      addSubtask(task.id, $refs.subtaskInput.value);
                      $refs.subtaskInput.value = '';
                    "
                    class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md"
                  >
                    âž•
                  </button>
                </div>
              </div>
              <!-- END SUBTASK SECTION -->

            </div>
          </template>
        </div>
        <!-- END TASK LIST -->
    </div>

    <!-- MAIN ALPINE COMPONENT SCRIPT -->
    <script>
    function mainApp() {
      return {
        // Dark mode
        darkMode: false,

        // TASK DATA
        tasks: [],
        subtasks: {},
        newTask: '',
        newDueDate: '',
        newPriority: 'medium',

        // AI AUTO-ADD
        showAutoAddModal: false,
        aiAutoAddResult: { main_task: '', subtasks: [] },
        isAILoading: false,

        // FILTER & SORT
        searchQuery: '',
        filterPriority: '',
        sortOption: 'dueAsc',

        // NOTIFICATIONS
        notifiedTasks: new Set(),
        notificationInterval: null,

        // =============================
        // INIT
        // =============================
        async init() {
          // Load theme preference
          const storedTheme = localStorage.getItem('theme');
          this.darkMode = (storedTheme === 'dark');

          // Fetch tasks & subtasks
          this.tasks = await this.fetchTasks();
          for (let t of this.tasks) {
            this.subtasks[t.id] = await this.fetchSubtasks(t.id);
          }

          // Notifications
          this.initNotifications();
        },

        toggleDarkMode() {
          this.darkMode = !this.darkMode;
          localStorage.setItem('theme', this.darkMode ? 'dark' : 'light');
        },

        // =============================
        // API / TASK METHODS
        // =============================
        async fetchTasks() {
          try {
            const resp = await fetch('/tasks');
            if (!resp.ok) throw new Error('Failed to fetch tasks');
            return await resp.json();
          } catch (err) {
            console.error('fetchTasks error:', err);
            return [];
          }
        },

        async fetchSubtasks(taskId) {
          try {
            const resp = await fetch(`/tasks/${taskId}/subtasks`);
            if (!resp.ok) return [];
            return await resp.json();
          } catch (err) {
            console.error('fetchSubtasks error:', err);
            return [];
          }
        },

        async addTask() {
          if (!this.newTask.trim()) {
            alert('Please enter a task or AI prompt!');
            return;
          }
          try {
            const resp = await fetch('/tasks', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                task: this.newTask,
                due_date: this.newDueDate || new Date().toISOString(),
                priority: this.newPriority
              })
            });
            if (!resp.ok) throw new Error('Failed to add task');

            // Reset fields
            this.newTask = '';
            this.newDueDate = '';
            this.newPriority = 'medium';

            // Refresh
            await this.refreshTasksWithSubtasks();
          } catch (err) {
            console.error('Add Task error:', err);
            alert('Add Task error: ' + err.message);
          }
        },

        async deleteTask(taskId) {
          try {
            const resp = await fetch(`/tasks/${taskId}`, { method: 'DELETE' });
            if (!resp.ok) throw new Error('Failed to delete task');

            this.tasks = this.tasks.filter(t => t.id !== taskId);
            delete this.subtasks[taskId];
          } catch (err) {
            console.error('Delete Task error:', err);
            alert('Delete Task error: ' + err.message);
          }
        },

        async toggleCompletion(taskId, completed) {
          try {
            const resp = await fetch(`/tasks/${taskId}/complete`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ completed })
            });
            if (!resp.ok) throw new Error('Failed to update completion');

            const idx = this.tasks.findIndex(t => t.id === taskId);
            this.tasks[idx].completed = completed;
          } catch (err) {
            console.error('Toggle completion error:', err);
          }
        },

        async addSubtask(taskId, text) {
          if (!text.trim()) {
            alert('Enter subtask text!');
            return;
          }
          try {
            const resp = await fetch(`/tasks/${taskId}/subtasks`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ subtask: text })
            });
            if (!resp.ok) {
              console.error('Failed to add subtask');
              return;
            }
            this.subtasks[taskId] = await this.fetchSubtasks(taskId);
          } catch (err) {
            console.error('Add subtask error:', err);
          }
        },

        async toggleSubtaskCompletion(taskId, subtask) {
          try {
            const resp = await fetch(`/tasks/${taskId}/subtasks/${subtask.id}/complete`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ completed: !subtask.completed })
            });
            if (!resp.ok) {
              console.error('Failed to toggle subtask completion');
              return;
            }
            subtask.completed = !subtask.completed;
          } catch (err) {
            console.error('Toggle subtask completion error:', err);
          }
        },

        async deleteSubtask(taskId, subtaskId) {
          try {
            const resp = await fetch(`/tasks/${taskId}/subtasks/${subtaskId}`, {
              method: 'DELETE'
            });
            if (!resp.ok) {
              console.error('Failed to delete subtask');
              return;
            }
            this.subtasks[taskId] = await this.fetchSubtasks(taskId);
          } catch (err) {
            console.error('Delete subtask error:', err);
          }
        },

        async refreshTasksWithSubtasks() {
          this.tasks = await this.fetchTasks();
          for (let t of this.tasks) {
            this.subtasks[t.id] = await this.fetchSubtasks(t.id);
          }
        },

        // =============================
        // AI AUTO-ADD
        // =============================
        async aiAutoAdd() {
          if (!this.newTask.trim()) {
            alert('Please enter a task or AI prompt first!');
            return;
          }
          try {
            this.isAILoading = true;
            const resp = await fetch('/ai/autogen', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ prompt: this.newTask })
            });
            const data = await resp.json();
            if (!resp.ok) {
              throw new Error(data.error || 'AI auto-add failed');
            }

            // Show AI result
            this.aiAutoAddResult = data; // { main_task: "", subtasks: [...] }
            this.showAutoAddModal = true;
          } catch (err) {
            console.error('AI Auto-Add error:', err);
            alert('AI Auto-Add error: ' + err.message);
          } finally {
            this.isAILoading = false;
          }
        },

        editAutoAdd() {
          // Copy AI's main_task to newTask
          this.newTask = this.aiAutoAddResult.main_task;
          this.showAutoAddModal = false;
        },

        async addAutoAdd() {
          // Create main task using newDueDate/newPriority
          try {
            const createResp = await fetch('/tasks', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                task: this.aiAutoAddResult.main_task,
                due_date: this.newDueDate || new Date().toISOString(),
                priority: this.newPriority
              })
            });
            if (!createResp.ok) throw new Error('Failed to create main task');

            // Refresh tasks
            await this.refreshTasksWithSubtasks();

            // Find newly created task by matching main_task
            const newTask = this.tasks.find(t => t.task === this.aiAutoAddResult.main_task);
            if (!newTask) {
              throw new Error('Could not locate newly created task');
            }

            // Insert subtasks
            if (this.aiAutoAddResult.subtasks && this.aiAutoAddResult.subtasks.length) {
              for (let item of this.aiAutoAddResult.subtasks) {
                const subResp = await fetch(`/tasks/${newTask.id}/subtasks`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ subtask: item })
                });
                if (!subResp.ok) {
                  console.error('Failed to add subtask:', item);
                }
              }
              // Refresh
              this.subtasks[newTask.id] = await this.fetchSubtasks(newTask.id);
            }

            this.showAutoAddModal = false;
            alert('AI Auto-Add: Task + Subtasks created!');
          } catch (err) {
            console.error('AddAutoAdd error:', err);
            alert('Error auto-adding task: ' + err.message);
          }
        },

        // =============================
        // SEARCH / FILTER / SORT
        // =============================
        searchQuery: '',
        filterPriority: '',
        sortOption: 'dueAsc',

        filteredAndSortedTasks() {
          // 1) Filter
          let filtered = this.tasks.filter(task => {
            const matchesSearch = this.searchQuery
              ? task.task.toLowerCase().includes(this.searchQuery.toLowerCase())
              : true;

            const matchesPriority = this.filterPriority
              ? (task.priority === this.filterPriority)
              : true;

            return matchesSearch && matchesPriority;
          });

          // 2) Sort
          filtered.sort((a, b) => {
            if (this.sortOption === 'dueAsc') {
              return new Date(a.due_date) - new Date(b.due_date);
            } else if (this.sortOption === 'dueDesc') {
              return new Date(b.due_date) - new Date(a.due_date);
            } else if (this.sortOption === 'priorityDesc') {
              return this.priorityValue(b.priority) - this.priorityValue(a.priority);
            } else if (this.sortOption === 'priorityAsc') {
              return this.priorityValue(a.priority) - this.priorityValue(b.priority);
            }
            return 0;
          });

          return filtered;
        },

        priorityValue(priority) {
          if (priority === 'high') return 3;
          if (priority === 'medium') return 2;
          if (priority === 'low') return 1;
          return 0;
        },

        // =============================
        // NOTIFICATIONS
        // =============================
        initNotifications() {
          if ('Notification' in window) {
            Notification.requestPermission().then(permission => {
              if (permission === 'granted') {
                setTimeout(() => this.checkDueTasks(), 5000);
                this.notificationInterval = setInterval(() => this.checkDueTasks(), 60000);
              }
            });
          }
        },

        async checkDueTasks() {
          try {
            const resp = await fetch('/tasks/due_soon');
            const dueTasks = await resp.json();
            dueTasks.forEach(task => {
              if (!this.notifiedTasks.has(task.id)) {
                this.showNotification(task);
                this.notifiedTasks.add(task.id);
              }
            });
          } catch (err) {
            console.error('checkDueTasks error:', err);
          }
        },

        showNotification(task) {
          if (Notification.permission === 'granted') {
            new Notification(`Task Due Soon: ${task.task}`, {
              body: `Due at ${new Date(task.due_date).toLocaleString()}`,
              icon: '/static/notification-icon.png',
              silent: false
            });
          }
        },

        testNotification() {
          this.showNotification({
            id: 0,
            task: "Test Notification",
            due_date: new Date().toISOString()
          });
        }
      };
    }
    </script>
</body>
</html>

